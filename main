(() => {
  'use strict';

  // ===== MODELOS DE MAPEAMENTO (dropdown) =====
  // COMO ADICIONAR NOVOS:
  // 1) Copie o JSON do mapeamento (o mesmo que você colaria no textarea).
  // 2) Cole abaixo como um novo item do objeto MODELS, ex.: "SK-Articles": { ... }.
  // 3) O <select> é populado automaticamente com as chaves de MODELS.
  const MODELS = {
    "BE-Articles": {
      "createdAt": "2025-09-10T19:32:22.632Z",
      "url": "https://live-74999-petcare-purinattt-belgium.pantheonsite.io/fr/node/10633/edit",
      "items": [
        {
          "id": "au0xkohly4fmfbgf81j",
          "ts": "2025-09-08T18:27:37.207Z",
          "url": "https://live-74999-petcare-purinattt-belgium.pantheonsite.io/nl/node/10630/edit?destination=/fr/admin/content%3Ftitle%3D%26type%3Dnppe_article%26langcode%3DAll%26moderation_state%3DAll",
          "title": "Edit Article De 100 beste namen waarop je kater gek zal zijn - Cloned [Dutch translation] | Purina BE",
          "field": {
            "label": "Body",
            "type": "textarea:textarea",
            "name": "field_article_lp_components[0][subform][field_c_text][0][value]",
            "id": "edit-field-article-lp-components-0-subform-field-c-text-0-value--vQapU4H8LA8",
            "dataDrupalSelector": "edit-field-article-lp-components-0-subform-field-c-text-0-value",
            "cssSelector": "#edit-field-article-lp-components-0-subform-field-c-text-0-value--vQapU4H8LA8",
            "wrapperSelector": "#edit-field-article-lp-components-0-subform-field-c-text-0-value--vQapU4H8LA8",
            "editor": "ckeditor"
          },
          "drupal": {
            "component": "field_article_lp_components",
            "componentIndex": 0,
            "subfield": "field_c_text",
            "subfieldIndex": 0,
            "property": "value",
            "nameTokens": [
              "field_article_lp_components",
              "0",
              "subform",
              "field_c_text",
              "0",
              "value"
            ]
          },
          "note": "Intro, must be h3"
        },
        {
          "id": "444hxgnavqxmfbgfaym",
          "ts": "2025-09-08T18:27:40.990Z",
          "url": "https://live-74999-petcare-purinattt-belgium.pantheonsite.io/nl/node/10630/edit?destination=/fr/admin/content%3Ftitle%3D%26type%3Dnppe_article%26langcode%3DAll%26moderation_state%3DAll",
          "title": "Edit Article De 100 beste namen waarop je kater gek zal zijn - Cloned [Dutch translation] | Purina BE",
          "field": {
            "label": "Body",
            "type": "textarea:textarea",
            "name": "field_article_lp_components[1][subform][field_c_text][0][value]",
            "id": "edit-field-article-lp-components-1-subform-field-c-text-0-value--iUJHCcCCZDQ",
            "dataDrupalSelector": "edit-field-article-lp-components-1-subform-field-c-text-0-value",
            "cssSelector": "#edit-field-article-lp-components-1-subform-field-c-text-0-value--iUJHCcCCZDQ",
            "wrapperSelector": "#edit-field-article-lp-components-1-subform-field-c-text-0-value--iUJHCcCCZDQ",
            "editor": "ckeditor"
          },
          "drupal": {
            "component": "field_article_lp_components",
            "componentIndex": 1,
            "subfield": "field_c_text",
            "subfieldIndex": 0,
            "property": "value",
            "nameTokens": [
              "field_article_lp_components",
              "1",
              "subform",
              "field_c_text",
              "0",
              "value"
            ]
          },
          "note": "First text block, will receive text with bold, italic, heading, listst and hyperlink"
        },
        {
          "id": "nroefvbbhnfmfbgfeg2",
          "ts": "2025-09-08T18:27:45.506Z",
          "url": "https://live-74999-petcare-purinattt-belgium.pantheonsite.io/nl/node/10630/edit?destination=/fr/admin/content%3Ftitle%3D%26type%3Dnppe_article%26langcode%3DAll%26moderation_state%3DAll",
          "title": "Edit Article De 100 beste namen waarop je kater gek zal zijn - Cloned [Dutch translation] | Purina BE",
          "field": {
            "label": "Inhoud",
            "type": "textarea:textarea",
            "name": "field_article_lp_components[2][subform][field_c_sideimagetext_summary][0][value]",
            "id": "edit-field-article-lp-components-2-subform-field-c-sideimagetext-summary-0-value--Quf7cXw7xO8",
            "dataDrupalSelector": "edit-field-article-lp-components-2-subform-field-c-sideimagetext-summary-0-value",
            "cssSelector": "#edit-field-article-lp-components-2-subform-field-c-sideimagetext-summary-0-value--Quf7cXw7xO8",
            "wrapperSelector": "#edit-field-article-lp-components-2-subform-field-c-sideimagetext-summary-0-value--Quf7cXw7xO8",
            "editor": "ckeditor"
          },
          "drupal": {
            "component": "field_article_lp_components",
            "componentIndex": 2,
            "subfield": "field_c_sideimagetext_summary",
            "subfieldIndex": 0,
            "property": "value",
            "nameTokens": [
              "field_article_lp_components",
              "2",
              "subform",
              "field_c_sideimagetext_summary",
              "0",
              "value"
            ]
          },
          "note": "First Image+Text\nWill recieve max 2 <p> with max 500 characters, suggest to move next p to next block if necessary"
        },
        {
          "id": "t7x5k8witcmfbgfh5t",
          "ts": "2025-09-08T18:27:49.025Z",
          "url": "https://live-74999-petcare-purinattt-belgium.pantheonsite.io/nl/node/10630/edit?destination=/fr/admin/content%3Ftitle%3D%26type%3Dnppe_article%26langcode%3DAll%26moderation_state%3DAll",
          "title": "Edit Article De 100 beste namen waarop je kater gek zal zijn - Cloned [Dutch translation] | Purina BE",
          "field": {
            "label": "Body",
            "type": "textarea:textarea",
            "name": "field_article_lp_components[3][subform][field_c_text][0][value]",
            "id": "edit-field-article-lp-components-3-subform-field-c-text-0-value--o-YYeSJ0yJI",
            "dataDrupalSelector": "edit-field-article-lp-components-3-subform-field-c-text-0-value",
            "cssSelector": "#edit-field-article-lp-components-3-subform-field-c-text-0-value--o-YYeSJ0yJI",
            "wrapperSelector": "#edit-field-article-lp-components-3-subform-field-c-text-0-value--o-YYeSJ0yJI",
            "editor": "ckeditor"
          },
          "drupal": {
            "component": "field_article_lp_components",
            "componentIndex": 3,
            "subfield": "field_c_text",
            "subfieldIndex": 0,
            "property": "value",
            "nameTokens": [
              "field_article_lp_components",
              "3",
              "subform",
              "field_c_text",
              "0",
              "value"
            ]
          },
          "note": "Second text block, will receive text with bold, italic, heading, listst and hyperlink"
        },
        {
          "id": "9uvzz505w9tmfbgfknh",
          "ts": "2025-09-08T18:27:53.549Z",
          "url": "https://live-74999-petcare-purinattt-belgium.pantheonsite.io/nl/node/10630/edit?destination=/fr/admin/content%3Ftitle%3D%26type%3Dnppe_article%26langcode%3DAll%26moderation_state%3DAll",
          "title": "Edit Article De 100 beste namen waarop je kater gek zal zijn - Cloned [Dutch translation] | Purina BE",
          "field": {
            "label": "Inhoud",
            "type": "textarea:textarea",
            "name": "field_article_lp_components[4][subform][field_c_sideimagetext_summary][0][value]",
            "id": "edit-field-article-lp-components-4-subform-field-c-sideimagetext-summary-0-value--lniD_3q0Clw",
            "dataDrupalSelector": "edit-field-article-lp-components-4-subform-field-c-sideimagetext-summary-0-value",
            "cssSelector": "#edit-field-article-lp-components-4-subform-field-c-sideimagetext-summary-0-value--lniD_3q0Clw",
            "wrapperSelector": "#edit-field-article-lp-components-4-subform-field-c-sideimagetext-summary-0-value--lniD_3q0Clw",
            "editor": "ckeditor"
          },
          "drupal": {
            "component": "field_article_lp_components",
            "componentIndex": 4,
            "subfield": "field_c_sideimagetext_summary",
            "subfieldIndex": 0,
            "property": "value",
            "nameTokens": [
              "field_article_lp_components",
              "4",
              "subform",
              "field_c_sideimagetext_summary",
              "0",
              "value"
            ]
          },
          "note": "Second Image+Text\nWill recieve max 2 <p> with max 500 characters, suggest to move next p to next block if necessary"
        },
        {
          "id": "cny2k2o5wfimfbgfqm9",
          "ts": "2025-09-08T18:28:01.281Z",
          "url": "https://live-74999-petcare-purinattt-belgium.pantheonsite.io/nl/node/10630/edit?destination=/fr/admin/content%3Ftitle%3D%26type%3Dnppe_article%26langcode%3DAll%26moderation_state%3DAll",
          "title": "Edit Article De 100 beste namen waarop je kater gek zal zijn - Cloned [Dutch translation] | Purina BE",
          "field": {
            "label": "Body",
            "type": "textarea:textarea",
            "name": "field_article_lp_components[5][subform][field_c_text][0][value]",
            "id": "edit-field-article-lp-components-5-subform-field-c-text-0-value--fCPRRXd3QrA",
            "dataDrupalSelector": "edit-field-article-lp-components-5-subform-field-c-text-0-value",
            "cssSelector": "#edit-field-article-lp-components-5-subform-field-c-text-0-value--fCPRRXd3QrA",
            "wrapperSelector": "#edit-field-article-lp-components-5-subform-field-c-text-0-value--fCPRRXd3QrA",
            "editor": "ckeditor"
          },
          "drupal": {
            "component": "field_article_lp_components",
            "componentIndex": 5,
            "subfield": "field_c_text",
            "subfieldIndex": 0,
            "property": "value",
            "nameTokens": [
              "field_article_lp_components",
              "5",
              "subform",
              "field_c_text",
              "0",
              "value"
            ]
          },
          "note": "Final text block, will receive text with bold, italic, heading, listst and hyperlink"
        },
        {
          "id": "fvnt8aktg9dmfbhrqo1",
          "ts": "2025-09-08T19:05:20.833Z",
          "url": "https://live-74999-petcare-purinattt-belgium.pantheonsite.io/nl/node/10630/edit?destination=/fr/admin/content%3Ftitle%3D%26type%3Dnppe_article%26langcode%3DAll%26moderation_state%3DAll",
          "title": "Edit Article De 100 beste namen waarop je kater gek zal zijn - Cloned [Dutch translation] | Purina BE",
          "field": {
            "label": "Page title",
            "type": "input:text",
            "name": "field_meta_tags[0][basic][title]",
            "id": "edit-field-meta-tags-0-basic-title",
            "dataDrupalSelector": "edit-field-meta-tags-0-basic-title",
            "cssSelector": "#edit-field-meta-tags-0-basic-title",
            "wrapperSelector": "#edit-field-meta-tags-0-basic-title",
            "editor": null
          },
          "drupal": {
            "component": "field_meta_tags",
            "componentIndex": 0,
            "subfield": null,
            "subfieldIndex": null,
            "property": null,
            "nameTokens": [
              "field_meta_tags",
              "0",
              "basic",
              "title"
            ]
          },
          "note": "Meta title"
        },
        {
          "id": "xlt2uij7fukmfbhs24w",
          "ts": "2025-09-08T19:05:35.696Z",
          "url": "https://live-74999-petcare-purinattt-belgium.pantheonsite.io/nl/node/10630/edit?destination=/fr/admin/content%3Ftitle%3D%26type%3Dnppe_article%26langcode%3DAll%26moderation_state%3DAll",
          "title": "Edit Article De 100 beste namen waarop je kater gek zal zijn - Cloned [Dutch translation] | Purina BE",
          "field": {
            "label": "Beschrijving",
            "type": "textarea:textarea",
            "name": "field_meta_tags[0][basic][description]",
            "id": "edit-field-meta-tags-0-basic-description",
            "dataDrupalSelector": "edit-field-meta-tags-0-basic-description",
            "cssSelector": "#edit-field-meta-tags-0-basic-description",
            "wrapperSelector": "#edit-field-meta-tags-0-basic-description",
            "editor": null
          },
          "drupal": {
            "component": "field_meta_tags",
            "componentIndex": 0,
            "subfield": null,
            "subfieldIndex": null,
            "property": null,
            "nameTokens": [
              "field_meta_tags",
              "0",
              "basic",
              "description"
            ]
          },
          "note": "Meta description"
        },
        {
          "id": "czurbgz2xu4mfbhscwq",
          "ts": "2025-09-08T19:05:49.658Z",
          "url": "https://live-74999-petcare-purinattt-belgium.pantheonsite.io/nl/node/10630/edit?destination=/fr/admin/content%3Ftitle%3D%26type%3Dnppe_article%26langcode%3DAll%26moderation_state%3DAll",
          "title": "Edit Article De 100 beste namen waarop je kater gek zal zijn - Cloned [Dutch translation] | Purina BE",
          "field": {
            "label": "Titel",
            "type": "input:text",
            "name": "field_meta_tags[0][open_graph][og_title]",
            "id": "edit-field-meta-tags-0-open-graph-og-title",
            "dataDrupalSelector": "edit-field-meta-tags-0-open-graph-og-title",
            "cssSelector": "#edit-field-meta-tags-0-open-graph-og-title",
            "wrapperSelector": "#edit-field-meta-tags-0-open-graph-og-title",
            "editor": null
          },
          "drupal": {
            "component": "field_meta_tags",
            "componentIndex": 0,
            "subfield": null,
            "subfieldIndex": null,
            "property": null,
            "nameTokens": [
              "field_meta_tags",
              "0",
              "open_graph",
              "og_title"
            ]
          },
          "note": "OG Title"
        },
        {
          "id": "x1yn3308a5hmfbhsk0x",
          "ts": "2025-09-08T19:05:58.881Z",
          "url": "https://live-74999-petcare-purinattt-belgium.pantheonsite.io/nl/node/10630/edit?destination=/fr/admin/content%3Ftitle%3D%26type%3Dnppe_article%26langcode%3DAll%26moderation_state%3DAll",
          "title": "Edit Article De 100 beste namen waarop je kater gek zal zijn - Cloned [Dutch translation] | Purina BE",
          "field": {
            "label": "Beschrijving",
            "type": "textarea:textarea",
            "name": "field_meta_tags[0][open_graph][og_description]",
            "id": "edit-field-meta-tags-0-open-graph-og-description",
            "dataDrupalSelector": "edit-field-meta-tags-0-open-graph-og-description",
            "cssSelector": "#edit-field-meta-tags-0-open-graph-og-description",
            "wrapperSelector": "#edit-field-meta-tags-0-open-graph-og-description",
            "editor": null
          },
          "drupal": {
            "component": "field_meta_tags",
            "componentIndex": 0,
            "subfield": null,
            "subfieldIndex": null,
            "property": null,
            "nameTokens": [
              "field_meta_tags",
              "0",
              "open_graph",
              "og_description"
            ]
          },
          "note": "OG Description"
        },
        {
          "id": "7kwijg7dnkvmfbhswkg",
          "ts": "2025-09-08T19:06:15.136Z",
          "url": "https://live-74999-petcare-purinattt-belgium.pantheonsite.io/nl/node/10630/edit?destination=/fr/admin/content%3Ftitle%3D%26type%3Dnppe_article%26langcode%3DAll%26moderation_state%3DAll",
          "title": "Edit Article De 100 beste namen waarop je kater gek zal zijn - Cloned [Dutch translation] | Purina BE",
          "field": {
            "label": "URL alias",
            "type": "input:text",
            "name": "path[0][alias]",
            "id": "edit-path-0-alias",
            "dataDrupalSelector": "edit-path-0-alias",
            "cssSelector": "#edit-path-0-alias",
            "wrapperSelector": "#edit-path-0-alias",
            "editor": null
          },
          "drupal": {
            "component": "path",
            "componentIndex": 0,
            "subfield": null,
            "subfieldIndex": null,
            "property": null,
            "nameTokens": [
              "path",
              "0",
              "alias"
            ]
          },
          "note": "URL (path without as example purina.be, if purina.be/xxx/xxx or purina.be/fr/xxx/xxx will receive only /xxx/xxx"
        },
        {
          "id": "88hwbm8rnm4mfedljrr",
          "ts": "2025-09-10T19:31:52.023Z",
          "url": "https://live-74999-petcare-purinattt-belgium.pantheonsite.io/fr/node/10633/edit",
          "title": "Edit Article 7 katvriendelijke snoepjes voor training | Purina BE",
          "field": {
            "label": "Internal title",
            "type": "input:text",
            "name": "field_article_internal_title[0][value]",
            "id": "edit-field-article-internal-title-0-value",
            "dataDrupalSelector": "edit-field-article-internal-title-0-value",
            "cssSelector": "#edit-field-article-internal-title-0-value",
            "wrapperSelector": "#edit-field-article-internal-title-0-value",
            "editor": null
          },
          "drupal": {
            "component": "field_article_internal_title",
            "componentIndex": 0,
            "subfield": null,
            "subfieldIndex": null,
            "property": null,
            "nameTokens": [
              "field_article_internal_title",
              "0",
              "value"
            ]
          },
          "note": "Recebe H1"
        },
        {
          "id": "oxhepgdc8dmfedlqvb",
          "ts": "2025-09-10T19:32:01.223Z",
          "url": "https://live-74999-petcare-purinattt-belgium.pantheonsite.io/fr/node/10633/edit",
          "title": "Edit Article 7 katvriendelijke snoepjes voor training | Purina BE",
          "field": {
            "label": "Titel",
            "type": "input:text",
            "name": "title[0][value]",
            "id": "edit-title-0-value",
            "dataDrupalSelector": "edit-title-0-value",
            "cssSelector": "#edit-title-0-value",
            "wrapperSelector": "#edit-title-0-value",
            "editor": null
          },
          "drupal": {
            "component": "title",
            "componentIndex": 0,
            "subfield": null,
            "subfieldIndex": null,
            "property": null,
            "nameTokens": [
              "title",
              "0",
              "value"
            ]
          },
          "note": "Recebe H1"
        },
        {
          "id": "07pivq3tyjbgmfedlyhj",
          "ts": "2025-09-10T19:32:11.095Z",
          "url": "https://live-74999-petcare-purinattt-belgium.pantheonsite.io/fr/node/10633/edit",
          "title": "Edit Article 7 katvriendelijke snoepjes voor training | Purina BE",
          "field": {
            "label": "Titel",
            "type": "input:text",
            "name": "field_meta_tags[0][open_graph][og_title]",
            "id": "edit-field-meta-tags-0-open-graph-og-title",
            "dataDrupalSelector": "edit-field-meta-tags-0-open-graph-og-title",
            "cssSelector": "#edit-field-meta-tags-0-open-graph-og-title",
            "wrapperSelector": "#edit-field-meta-tags-0-open-graph-og-title",
            "editor": null
          },
          "drupal": {
            "component": "field_meta_tags",
            "componentIndex": 0,
            "subfield": null,
            "subfieldIndex": null,
            "property": null,
            "nameTokens": [
              "field_meta_tags",
              "0",
              "open_graph",
              "og_title"
            ]
          },
          "note": "og title"
        },
        {
          "id": "77i992nznfmfedm300",
          "ts": "2025-09-10T19:32:16.944Z",
          "url": "https://live-74999-petcare-purinattt-belgium.pantheonsite.io/fr/node/10633/edit",
          "title": "Edit Article 7 katvriendelijke snoepjes voor training | Purina BE",
          "field": {
            "label": "Beschrijving",
            "type": "textarea:textarea",
            "name": "field_meta_tags[0][open_graph][og_description]",
            "id": "edit-field-meta-tags-0-open-graph-og-description",
            "dataDrupalSelector": "edit-field-meta-tags-0-open-graph-og-description",
            "cssSelector": "#edit-field-meta-tags-0-open-graph-og-description",
            "wrapperSelector": "#edit-field-meta-tags-0-open-graph-og-description",
            "editor": null
          },
          "drupal": {
            "component": "field_meta_tags",
            "componentIndex": 0,
            "subfield": null,
            "subfieldIndex": null,
            "property": null,
            "nameTokens": [
              "field_meta_tags",
              "0",
              "open_graph",
              "og_description"
            ]
          },
          "note": "og description"
        }
      ]
    }
    // ==== Adicione novos modelos aqui ====
    // "SK-Articles": { ... },
    // "IT-Articles": { ... }
  };

  const ID = 'nppe-paste-fill';
  document.getElementById(ID)?.remove();
  document.getElementById(ID + '-style')?.remove();

  const css = `
  #${ID}{position:fixed;inset:0;z-index:2147483647;background:rgba(0,0,0,.55);display:flex;align-items:center;justify-content:center}
  #${ID} .box{width:min(1200px,96vw);max-height:94vh;background:#0f1115;color:#eaeef3;border-radius:14px;box-shadow:0 12px 40px rgba(0,0,0,.6);display:flex;flex-direction:column}
  #${ID} .hd{display:flex;align-items:center;gap:12px;padding:14px 16px;border-bottom:1px solid #23262d}
  #${ID} .hd h3{margin:0;font:600 16px/1.3 system-ui}
  #${ID} .bd{display:grid;grid-template-columns:340px 1fr;gap:12px;padding:12px 16px;overflow:auto}
  #${ID} .col{display:flex;flex-direction:column;gap:10px}
  #${ID} textarea{width:100%;min-height:160px;background:#12151c;color:#eaeef3;border:1px solid #2a2f3a;border-radius:10px;padding:10px 12px;font:13px/1.5 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace}
  #${ID} select{width:100%;background:#12151c;color:#eaeef3;border:1px solid #2a2f3a;border-radius:10px;padding:10px 12px;font:13px/1.5 system-ui}
  #${ID} input[type="file"]{width:100%}
  #${ID} .btns{display:flex;gap:8px;padding:12px 16px;border-top:1px solid #23262d;justify-content:flex-end}
  #${ID} button{background:#2a6df5;border:none;color:#fff;border-radius:10px;padding:9px 12px;font:600 13px/1 system-ui;cursor:pointer}
  #${ID} button.secondary{background:#1f2430}
  #${ID} .log{white-space:pre-wrap;background:#0b0d12;border:1px solid #23262d;border-radius:10px;padding:10px;min-height:120px}
  #${ID} .toolbar{display:flex;flex-wrap:wrap;gap:6px;padding:6px;background:#0b0d12;border:1px solid #23262d;border-radius:10px}
  #${ID} .toolbar button{background:#17202f}
  #${ID} .editor{min-height:220px;background:#11151d;border:1px solid #23262d;border-radius:12px;padding:12px;overflow:auto}
  #${ID} .grid2{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  #${ID} .blk{background:#0b0d12;border:1px solid #23262d;border-radius:10px;padding:8px}
  #${ID} .blk h4{margin:0 0 6px;font:600 13px system-ui;color:#c9d7ff}
  #${ID} .blk .ed{min-height:120px;background:#11151d;border:1px solid #23262d;border-radius:8px;padding:8px;overflow:auto}
  #${ID} .blk .mini{display:flex;gap:8px;align-items:center;margin:6px 0 8px}
  #${ID} .blk .mini select{background:#0f1522;color:#eaeef3;border:1px solid #2a2f3a;border-radius:8px;padding:6px 8px}
  #${ID} .blk .mini button{background:#17202f}
  #${ID} details.ed-wrap{background:#0b0d12;border:1px solid #23262d;border-radius:10px}
  #${ID} details.ed-wrap>summary{cursor:pointer;padding:8px 10px;user-select:none;list-style:none;color:#c9d7ff}
  #${ID} details.ed-wrap[open] .toolbar, #${ID} details.ed-wrap[open] .editor{display:block}
  #${ID} details.ed-wrap:not([open]) .toolbar, #${ID} details.ed-wrap:not([open]) .editor{display:none}
  .meta-preview{font:13px/1.5 system-ui;background:#11151d;border:1px solid #23262d;border-radius:8px;padding:8px;margin-top:6px;color:#ccc}
  .meta-preview div{margin-bottom:4px}
  .boldlist{display:flex;flex-direction:column;gap:8px;margin-top:8px}
  .bolditem{display:grid;grid-template-columns:1fr 130px;gap:8px;align-items:center;background:#0b0d12;border:1px solid #23262d;border-radius:8px;padding:8px}
  .bolditem .txt{font:13px/1.5 system-ui;color:#eaeef3;word-break:break-word}
  .bolditem select{background:#0f1522;color:#eaeef3;border:1px solid #2a2f3a;border-radius:8px;padding:6px 8px}
  .bold-actions{display:flex;gap:8px;margin-top:8px}
  #${ID} .md-hint{font:12px/1.4 system-ui;color:#9aa6b2;margin-top:-4px;margin-bottom:6px}
  #${ID} #${ID}-md{width:100%;min-height:160px;background:#12151c;color:#eaeef3;border:1px solid #2a2f3a;border-radius:10px;padding:10px 12px;font:13px/1.5 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace}

  @keyframes nppePulse {0%{box-shadow:0 0 0 0 rgba(42,109,245,.65)}70%{box-shadow:0 0 0 10px rgba(42,109,245,0)}100%{box-shadow:0 0 0 0 rgba(42,109,245,0)}}
  .nppe-pulse{animation:nppePulse 1.2s ease-out 1; outline:2px solid #2a6df5; outline-offset:2px; border-radius:8px}
  `;
  const style = Object.assign(document.createElement('style'), { id: ID + '-style', textContent: css });
  document.head.appendChild(style);

  const wrap = Object.assign(document.createElement('div'), { id: ID });
  wrap.innerHTML = `
    <div class="box">
      <div class="hd">
        <h3>NPPE – Paste Filler (Organizer v6)</h3>
      </div>
      <div class="bd">
        <div class="col">
          <label><b>Modelo de mapeamento:</b></label>
          <select id="${ID}-model"></select>
          <div>
            <label><b>.docx (opcional):</b></label>
            <input id="${ID}-docx" type="file" accept=".docx">
          </div>
        <div>
<label><b>Markdown (opcional):</b></label>
<div class="md-hint">Cole aqui seu conteúdo em Markdown. Em <i>Analisar</i>, ele será convertido e enviado ao Editor.</div>
<textarea id="${ID}-md" placeholder="# Título

Intro (H3):
Texto...

**Negrito** e _itálico_, listas:
- item
1. item

[link](https://exemplo.com)"></textarea>
          </div>
          <div class="log" id="${ID}-log">Pronto…</div>
        </div>
        <div class="col">

          <!-- Meta & H1 -->
          <details class="ed-wrap" id="${ID}-meta-wrap">
            <summary>Meta & H1</summary>
            <div class="blk"><h4>H1</h4><div id="${ID}-h1" class="ed" contenteditable="true"></div></div>
            <div class="meta-preview" id="${ID}-meta-preview"></div>
          </details>

          <!-- Bold → Headings -->
          <details class="ed-wrap" id="${ID}-bold-wrap">
            <summary>Bold → Headings (H2/H3/H4)</summary>
            <div class="meta-preview">Selecione abaixo como cada sentença em negrito deve virar heading. Conversões serão aplicadas no Editor e nos Blocos.</div>
            <div id="${ID}-bold-list" class="boldlist"></div>
            <div class="bold-actions">
              <button class="secondary" id="${ID}-bold-rescan">Revarrer bolds</button>
              <button id="${ID}-bold-apply">Aplicar conversões</button>
            </div>
          </details>

          <details class="ed-wrap" id="${ID}-ed-wrap">
            <summary>Editor (opcional)</summary>
            <div class="toolbar">$1
            <button type="button" data-act="md-to-editor" title="Converter Markdown para Editor">MD→Editor</button></div>
            <div id="${ID}-editor" class="editor" contenteditable="true" aria-label="Editor (tipo CK)"></div>
          </details>

          <div class="grid2" style="margin-top:10px">
            <div class="blk"><h4>Intro (H3)</h4><div id="${ID}-intro" class="ed" contenteditable="true"></div></div>
            <div class="blk"><h4>Text block 1</h4><div id="${ID}-t1" class="ed" contenteditable="true"></div></div>
            <div class="blk"><h4>Image+Text 1 (summary)</h4><div id="${ID}-i1" class="ed" contenteditable="true"></div></div>
            <div class="blk"><h4>Text block 2</h4><div id="${ID}-t2" class="ed" contenteditable="true"></div></div>
            <div class="blk"><h4>Image+Text 2 (summary)</h4><div id="${ID}-i2" class="ed" contenteditable="true"></div></div>
            <div class="blk"><h4>Text block 3</h4><div id="${ID}-t3" class="ed" contenteditable="true"></div></div>
          </div>
        </div>
      </div>
      <div class="btns">
        <button class="secondary" id="${ID}-sanitize">Sanitizar</button>
        <button class="secondary" id="${ID}-autotag">Auto-Tag</button>
        <button class="secondary" id="${ID}-analyze">Analisar</button>
        <button class="secondary" id="${ID}-extract">Extrair → Blocos</button>
        <button id="${ID}-fill">Preencher Drupal</button>
        <button class="secondary" id="${ID}-close">Fechar</button>
      </div>
    </div>
  `;
  document.body.appendChild(wrap);

  // Popula o dropdown com as chaves de MODELS
  (() => {
    const sel = wrap.querySelector(`#${ID}-model`);
    const keys = Object.keys(MODELS);
    sel.innerHTML = keys.map(k => `<option value="${k}">${k}</option>`).join('');
    if (keys.length) sel.value = keys[0];
  })();

  // ===== Headings & Listify por bloco =====
  const firstBlock = (ed) => {
    const isBlock = n => n && n.nodeType === 1 && /^(P|H2|H3|UL|OL)$/i.test(n.tagName) && n.textContent.trim() !== '';
    let n = ed.firstChild; while (n && !isBlock(n)) n = n.nextSibling; return n;
  };
  const applyHeading = (ed, level) => {
    let n = firstBlock(ed);
    if (!n) { n = document.createElement('p'); n.innerHTML = ''; ed.prepend(n); }
    if (level === 'p' && n.tagName !== 'P') {
      const p = document.createElement('p'); p.innerHTML = n.innerHTML; n.replaceWith(p); return;
    }
    if (level === 'h2' || level === 'h3') {
      const tag = level.toUpperCase();
      if (n.tagName !== tag) { const hx = document.createElement(tag); hx.innerHTML = n.innerHTML; n.replaceWith(hx); }
    }
  };
  const listifyRest = (ed) => {
    const start = firstBlock(ed); if (!start) return;
    const toList = [];
    for (let n = start.nextSibling; n; n = n.nextSibling) {
      if (n.nodeType === 1 && n.tagName === 'P' && n.textContent.trim() !== '') toList.push(n);
    }
    if (toList.length < 2) return;
    const ul = document.createElement('ul');
    toList.forEach(p => { const li = document.createElement('li'); li.innerHTML = p.innerHTML; ul.appendChild(li); });
    const ref = start.nextSibling;
    toList.forEach(p => p.remove());
    ed.insertBefore(ul, ref);
  };
  // mini-controls nos blocos da grade
  const createMiniControls = () => {
    wrap.querySelectorAll('.grid2 .blk').forEach((blk, idx) => {
      const ed = blk.querySelector('.ed');
      const mini = document.createElement('div');
      mini.className = 'mini';
      mini.innerHTML = `
        <label>Nível</label>
        <select data-level>
          <option value="h2">H2</option>
          <option value="h3" ${idx === 0 ? 'selected' : ''}>H3</option>
          <option value="p"  ${idx !== 0 ? 'selected' : ''}>Parágrafo</option>
        </select>
        <button type="button" data-act="listify">Parágrafos → Lista</button>
      `;
      blk.insertBefore(mini, ed);
      const sel = mini.querySelector('select');
      const btn = mini.querySelector('button');
      sel.addEventListener('change', e => applyHeading(ed, e.target.value));
      btn.addEventListener('click', () => listifyRest(ed));
    });
  };
  createMiniControls();

  // ===== Refs
  const $ = sel => wrap.querySelector(sel);
  const $model = $(`#${ID}-model`);
  const $docx = $(`#${ID}-docx`);
  const $md = $(`#${ID}-md`);
  const $log = $(`#${ID}-log`);
  const $ed = $(`#${ID}-editor`);
  const $h1 = $(`#${ID}-h1`);
  const $metaPreview = $(`#${ID}-meta-preview`);
  const $boldList = $(`#${ID}-bold-list`);
  const $boldRescan = $(`#${ID}-bold-rescan`);
  const $boldApply = $(`#${ID}-bold-apply`);
  const $autotag = $(`#${ID}-autotag`);
  const $extract = $(`#${ID}-extract`);
  const $sanitize = $(`#${ID}-sanitize`);
  const $analyze = $(`#${ID}-analyze`);
  const $fill = $(`#${ID}-fill`);
  const $close = $(`#${ID}-close`);
  const $intro = $(`#${ID}-intro`), $t1 = $(`#${ID}-t1`), $t2 = $(`#${ID}-t2`), $t3 = $(`#${ID}-t3`), $i1 = $(`#${ID}-i1`), $i2 = $(`#${ID}-i2`);

  const log = (...a) => { $log.textContent = a.join(' '); };
  const pulse = (node) => { const box = node?.closest('.js-form-item,.form-item,.paragraphs-subform,.form-wrapper') || node; if (box) { box.classList.add('nppe-pulse'); setTimeout(() => box.classList.remove('nppe-pulse'), 1200); } };

  // ===== Helpers =====
  const waitFor = (fnOrSel, { timeout = 8000, interval = 120 } = {}) => new Promise((resolve, reject) => {
    const t0 = performance.now();
    const tick = () => {
      try {
        const val = typeof fnOrSel === 'function' ? fnOrSel() : document.querySelector(fnOrSel);
        if (val) return resolve(val);
        if (performance.now() - t0 > timeout) return reject(new Error('Timeout: ' + (fnOrSel.toString?.() || fnOrSel)));
        setTimeout(tick, interval);
      } catch (e) { reject(e); }
    };
    tick();
  });

  const ensureZip = () => new Promise((resolve, reject) => {
    if (window.JSZip) return resolve();
    const s = document.createElement('script'); s.src = 'https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js';
    s.onload = () => resolve(); s.onerror = () => reject(new Error('Falha ao carregar JSZip')); document.head.appendChild(s);
  });

  // permitir H1
  const allowed = new Set(['DIV', 'P', 'STRONG', 'EM', 'UL', 'OL', 'LI', 'A', 'H1', 'H2', 'H3', 'H4', 'BR']);
  const sanitizeHTML = (html) => {
    const tmp = document.createElement('div'); tmp.innerHTML = html || '';

    const sanitizeUrl = (u) => {
      if (!u) return '';
      const url = String(u).trim();
      const low = url.toLowerCase();
      if (low.startsWith('javascript:') || low.startsWith('data:') || low.startsWith('vbscript:')) return '';
      return url;
    };

    const walk = (node) => {
      for (let c = node.firstChild; c;) {
        const n = c.nextSibling;
        if (c.nodeType === 1) {
          const tag = c.tagName;
          if (!allowed.has(tag)) {
            while (c.firstChild) node.insertBefore(c.firstChild, c);
            node.removeChild(c);
            c = n; continue;
          }
          if (tag === 'A') {
            let href = c.getAttribute('href');
            href = sanitizeUrl(href);
            if (href) c.setAttribute('href', href); else c.removeAttribute('href');

            const allowedTargets = new Set(['_blank', '_self', '_parent', '_top']);
            let target = (c.getAttribute('target') || '').trim().toLowerCase();
            if (!allowedTargets.has(target)) {
              c.removeAttribute('target');
            } else {
              c.setAttribute('target', target);
              if (target === '_blank') {
                const relNow = (c.getAttribute('rel') || '').toLowerCase().split(/\s+/).filter(Boolean);
                if (!relNow.includes('noopener')) relNow.push('noopener');
                if (!relNow.includes('noreferrer')) relNow.push('noreferrer');
                c.setAttribute('rel', Array.from(new Set(relNow)).join(' '));
              }
            }
            [...c.attributes].forEach(a => {
              const nm = a.name.toLowerCase();
              if (nm !== 'href' && nm !== 'target' && nm !== 'rel') c.removeAttribute(a.name);
            });
          } else {
            [...c.attributes].forEach(a => c.removeAttribute(a.name));
          }
          walk(c);
        }
        c = n;
      }
    };

    walk(tmp);
    return tmp.innerHTML
      .replace(/<p>\s*<\/p>/gi, '')
      .replace(/(\s*<br\s*\/?>(\s|&nbsp;)*){2,}/gi, '<br>');
  };

  const esc = (s) => String(s).replace(/[&<>]/g, m => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;' }[m]));
  const plainToHTML = (txt) => {
    return txt.trim().split(/\r?\n\r?\n+/).map(p => `<p>${esc(p).replace(/(https?:\/\/\S+)/g, '<a href="$1">$1<\/a>')}</p>`).join('');
  };
  const htmlFromClipboardOrText = (input) => (/(<p|<h\d|<ul|<ol|<li|<strong|<em|<a|<br)/i.test(input) ? input : plainToHTML(input));
  // ===== Markdown → HTML (parser leve, focado no escopo editorial) =====

  // ✅ Helper: capitaliza a 1ª letra "real" e garante ponto final
  const sentenceCase = (s) => {
    s = String(s || '').trim();
    if (!s) return s;

    const m = s.match(/^([\(\[\{"'“‘]*)/);
    const lead = m ? m[1] : '';
    let rest = s.slice(lead.length);

    // encontra a primeira letra (inclui acentuadas)
    const idx = rest.search(/[A-Za-zÀ-ÖØ-öø-ÿ]/);
    if (idx >= 0) {
      rest = rest.slice(0, idx) + rest.charAt(idx).toUpperCase() + rest.slice(idx + 1);
    }

    let out = lead + rest;
    if (!/[.!?…]$/.test(out)) out += '.';
    return out;
  };

  const markdownToHTML = (md) => {
    if (!md || !md.trim()) return '';
    const escHtml = (s) => s
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;');

    // Normaliza quebra de linha
    md = md
      .replace(/•\s*/g, '\n- ')
      .replace(/\r\n?/g, '\n');

    // Blocos por linhas
    const lines = md.split('\n');

    // Acumuladores
    let out = [];
    let buf = [];
    let listMode = null; // 'ul' | 'ol'

    const flushPara = () => {
      if (!buf.length) return;
      const text = buf.join(' ').trim();
      if (text) out.push(`<p>${text}</p>`);
      buf = [];
    };
    const flushList = () => {
      if (!listMode) return;
      out.push(`</${listMode}>`);
      listMode = null;
    };

    const emitListItem = (html, isOrdered) => {
      if (!listMode) {
        listMode = isOrdered ? 'ol' : 'ul';
        out.push(`<${listMode}>`);
      } else if ((isOrdered && listMode !== 'ol') || (!isOrdered && listMode !== 'ul')) {
        // troca de tipo de lista
        flushList();
        listMode = isOrdered ? 'ol' : 'ul';
        out.push(`<${listMode}>`);
      }
      out.push(`<li>${html}</li>`);
    };

    const inline = (s) => {
      // Padrão específico: (texto ancora)[https://url]
      s = s.replace(/\(([^)]+)\)\s*\[\s*(https?:\/\/[^\]\s]+)\s*\]/g,
        (m, t, u) => `<a href="${u}">${esc(t)}</a>`);
      // [texto](url)
      s = s.replace(/\[([^\]]+)\]\(\s*(https?:\/\/[^\s)]+)\s*\)/g, (m, t, u) => `<a href="${u}">${esc(t)}</a>`);
      // [texto]: url
      s = s.replace(/\[([^\]]+)\]\s*[:：]\s*(https?:\/\/\S+)/g, (m, t, u) => `<a href="${u}">${esc(t)}</a>`);
      // ...PALAVRA [https://url]  → ancora a PALAVRA anterior (ou **bold**/**_itálico_** anterior)
      s = s.replace(/((?:<strong>[^<]+<\/strong>|<em>[^<]+<\/em>|[^\s<][^<\s]*))\s*\[\s*(https?:\/\/[^\]\s]+)\s*\]/g,
        (m, txt, u) => `<a href="${u}">${txt}</a>`);
      // Autolink simples [https://...] (fallback)
      s = s.replace(/\[(https?:\/\/[^\s\]]+)\]/g, (m, u) => `<a href="${u}">${u}</a>`);
      // Bold **x** ou __x__
      s = s.replace(/(\*\*|__)(.+?)\1/g, '<strong>$2</strong>');
      // Italic *x* ou _x_
      s = s.replace(/(^|[^\*])\*(?!\s)(.+?)(?<!\s)\*(?!\*)/g, '$1<em>$2</em>');
      s = s.replace(/(^|[^_])_(?!\s)(.+?)(?<!\s)_(?!_)/g, '$1<em>$2</em>');
      return s;
    };
    const esc = (s) => s; // já escapamos seletivamente

    for (let i = 0; i < lines.length; i++) {
      let line = lines[i];

      // Ignora cercas de code block (não suportamos <pre> no sanitizer atual)
      if (/^\s*```/.test(line)) { continue; }

      // Heading ATX: ###, ##, #
      let m;
      if (m = line.match(/^\s*#{3}\s+(.+)$/)) {
        flushPara(); flushList();
        out.push(`<h3>${inline(escHtml(m[1].trim()))}</h3>`);
        continue;
      }
      if (m = line.match(/^\s*#{2}\s+(.+)$/)) {
        flushPara(); flushList();
        out.push(`<h2>${inline(escHtml(m[1].trim()))}</h2>`);
        continue;
      }
      if (m = line.match(/^\s*#\s+(.+)$/)) {
        flushPara(); flushList();
        out.push(`<h1>${inline(escHtml(m[1].trim()))}</h1>`);
        continue;
      }

      // Lista ordenada: 1. item
      if (m = line.match(/^\s*(\d+)[.)]\s+(.+)$/)) {
        flushPara();
        emitListItem(inline(escHtml(sentenceCase(m[2].trim()))), true);
        continue;
      }

      // Lista não ordenada: -, *, +
      if (m = line.match(/^\s*[-*+]\s+(.+)$/)) {
        flushPara();
        emitListItem(inline(escHtml(sentenceCase(m[1].trim()))), false);
        continue;
      }

      // Linha em branco → quebra de parágrafo/lista
      if (!line.trim()) {
        flushPara(); flushList();
        continue;
      }

      // Texto contínuo → acumula para <p>
      buf.push(inline(escHtml(line.trim())));
    }

    flushPara(); flushList();

    // Quebras duplas em <br>
    const html = out.join('\n').replace(/ {2}\n/g, '<br>\n');
    return sanitizeHTML(html);
  };

  // === Helpers extra (remover aspas e detectar frase) ===
  const dequote = (s) => String(s || '')
    .trim()
    .replace(/^[\s"'“”«»„‚‘’]+|[\s"'“”«»„‚‘’]+$/g, '');

  const isUpperStart = (s) => /^[A-ZÀ-ÖØ-Ý]/.test(String(s || '').trim());

  // Extrai a frase inteira do bloco que contém o trecho em negrito
  const getSentenceAround = (full, sub) => {
    const text = (full || '').trim();
    const needle = (sub || '').trim();
    const i = text.indexOf(needle);
    if (i < 0) return null;
    // Pontuações comuns de fim de frase
    const seps = /[.!?;:…]/g;
    let start = 0, end = text.length, m;

    // Busca separador ANTES do trecho
    while ((m = seps.exec(text)) && m.index < i) start = m.index + 1;

    // Reinicia busca e pega separador DEPOIS do trecho
    seps.lastIndex = 0;
    let lastEnd = end;
    while ((m = seps.exec(text)) && m.index <= i + needle.length - 1) lastEnd = m.index + 1;
    end = lastEnd;

    return text.slice(start, end).trim();
  };

  // ===== DOCX → HTML (mantém H1) =====
  const getDocxHTML = async (file) => {
    await ensureZip();
    const z = await JSZip.loadAsync(await file.arrayBuffer());
    const docXml = await z.file('word/document.xml')?.async('string');
    const relsXml = await z.file('word/_rels/document.xml.rels')?.async('string') || '';
    const numXml = await z.file('word/numbering.xml')?.async('string') || '';
    if (!docXml) throw new Error('Documento Word inválido');

    const parse = (s) => new DOMParser().parseFromString(s, 'application/xml');
    const W_NS = 'http://schemas.openxmlformats.org/wordprocessingml/2006/main';
    const R_NS = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships';
    const A_NS = 'http://schemas.openxmlformats.org/drawingml/2006/main';

    const doc = parse(docXml);
    const rels = relsXml ? parse(relsXml) : null;
    const num = numXml ? parse(numXml) : null;

    const relMap = {};
    if (rels) Array.from(rels.getElementsByTagName('Relationship')).forEach(r => {
      const id = r.getAttribute('Id');
      const t = r.getAttribute('Target');
      if (id && t) relMap[id] = t;
    });

    const numIdToAbs = {};
    const absLvlToFmt = {};
    if (num) {
      Array.from(num.getElementsByTagNameNS(W_NS, 'num')).forEach(n => {
        const numId = n.getAttributeNS(W_NS, 'numId');
        const absEl = n.getElementsByTagNameNS(W_NS, 'abstractNumId')[0];
        const absId = absEl?.getAttributeNS(W_NS, 'val');
        if (numId && absId) numIdToAbs[numId] = absId;
      });
      Array.from(num.getElementsByTagNameNS(W_NS, 'abstractNum')).forEach(a => {
        const absId = a.getAttributeNS(W_NS, 'abstractNumId');
        Array.from(a.getElementsByTagNameNS(W_NS, 'lvl')).forEach(lvl => {
          const ilvl = lvl.getAttributeNS(W_NS, 'ilvl') || '0';
          const fmt = lvl.getElementsByTagNameNS(W_NS, 'numFmt')[0]?.getAttributeNS(W_NS, 'val') || 'bullet';
          absLvlToFmt[`${absId}:${ilvl}`] = fmt;
        });
      });
    }

    const listInfo = (p) => {
      const numPr = p.getElementsByTagNameNS(W_NS, 'numPr')[0];
      if (!numPr) return null;
      const numIdEl = numPr.getElementsByTagNameNS(W_NS, 'numId')[0];
      if (!numIdEl) return null;
      const ilvlEl = numPr.getElementsByTagNameNS(W_NS, 'ilvl')[0];
      const numId = numIdEl.getAttributeNS(W_NS, 'val');
      const ilvl = ilvlEl?.getAttributeNS(W_NS, 'val') || '0';
      const absId = numIdToAbs[numId];
      const fmt = absLvlToFmt[`${absId}:${ilvl}`] || 'bullet';
      const type = /decimal|lowerRoman|upperRoman|lowerLetter|upperLetter/i.test(fmt) ? 'ol' : 'ul';
      return { type, level: parseInt(ilvl, 10) || 0 };
    };

    const headingTag = (p) => {
      const ps = p.getElementsByTagNameNS(W_NS, 'pStyle')[0];
      const v = ps?.getAttributeNS(W_NS, 'val') || '';
      const m = v.match(/Heading([1-6])/i);
      if (m) {
        const lvl = parseInt(m[1], 10);
        if (lvl === 1) return 'h1';
        if (lvl === 2) return 'h2';
        if (lvl === 3) return 'h3';
        return 'h4';
      }
      // Fallback: Check font size (sz) - 36 = 18pt, 48 = 24pt
      const pPr = p.getElementsByTagNameNS(W_NS, 'pPr')[0];
      const rPr = pPr?.getElementsByTagNameNS(W_NS, 'rPr')[0];
      const sz = rPr?.getElementsByTagNameNS(W_NS, 'sz')[0];
      if (sz) {
        const val = parseInt(sz.getAttributeNS(W_NS, 'val'), 10);
        if (val >= 48) return 'h2';
        if (val >= 36) return 'h3';
      }
      return null;
    };

    const smartJoin = (acc, piece) => {
      if (!acc) return piece;
      const a = acc.slice(-1), b = piece[0];
      if (a && b && !(/[\s>]/.test(a)) && !(/[\s,.;:!?)]/.test(b))) return acc + ' ' + piece;
      return acc + piece;
    };

    const textFromRun = async (r) => {
      const rPr = r.getElementsByTagNameNS(W_NS, 'rPr')[0];
      const isB = !!rPr?.getElementsByTagNameNS(W_NS, 'b')[0];
      const isI = !!rPr?.getElementsByTagNameNS(W_NS, 'i')[0];
      let out = '';

      for (const n of Array.from(r.childNodes)) {
        if (n.namespaceURI !== W_NS) continue;
        switch (n.localName) {
          case 't': out = smartJoin(out, esc(n.textContent || '')); break;
          case 'tab': out = smartJoin(out, ' '); break;
          case 'softHyphen': out += '\u00AD'; break;
          case 'br': out += '<br>'; break;
          case 'drawing': {
            // Extract image
            const blip = n.getElementsByTagNameNS(A_NS, 'blip')[0];
            const embedId = blip?.getAttributeNS(R_NS, 'embed');
            if (embedId && relMap[embedId]) {
              const imgPath = 'word/' + relMap[embedId];
              try {
                const imgData = await z.file(imgPath)?.async('base64');
                if (imgData) {
                  const ext = imgPath.split('.').pop().toLowerCase();
                  const mime = ext === 'png' ? 'image/png' : (ext === 'jpeg' || ext === 'jpg' ? 'image/jpeg' : 'image/gif');
                  out += `<img src="data:${mime};base64,${imgData}" alt="Image">`;
                }
              } catch (e) {
                console.warn('Failed to load image:', imgPath, e);
              }
            }
            break;
          }
          default: break;
        }
      }

      if (!out) return '';
      if (isB) out = `<strong>${out}</strong>`;
      if (isI) out = `<em>${out}</em>`;
      return out;
    };

    const renderInline = async (container) => {
      let acc = '';
      for (const n of Array.from(container.childNodes)) {
        if (n.namespaceURI !== W_NS) continue;
        if (n.localName === 'r') acc = smartJoin(acc, await textFromRun(n));
        else if (n.localName === 'hyperlink') {
          const rid = n.getAttributeNS(R_NS, 'id') || n.getAttribute('r:id');
          const url = rid ? (relMap[rid] || '#') : '#';
          const inner = await renderInline(n);
          acc = smartJoin(acc, `<a href="${esc(url)}">${inner}</a>`);
        } else if (n.localName === 'br') acc += '<br>';
        else if (n.localName === 'tab') acc = smartJoin(acc, ' ');
        else if (n.localName === 'softHyphen') acc += '\u00AD';
      }
      return acc.trim();
    };

    let html = '';
    const ps = Array.from(doc.getElementsByTagNameNS(W_NS, 'p'));
    const listStack = [];
    const closeListsTo = (targetLevel) => {
      while (listStack.length - 1 > targetLevel) {
        const last = listStack.pop();
        html += `</${last.type}>`;
      }
    };

    for (const p of ps) {
      const content = await renderInline(p);
      if (!content && !p.getElementsByTagNameNS(W_NS, 'drawing').length) continue; // Skip empty unless drawing

      const h = headingTag(p);
      const li = listInfo(p);

      if (li) {
        if (listStack.length === 0) {
          html += `<${li.type}>`; listStack.push({ type: li.type });
        } else {
          const curLevel = listStack.length - 1;
          if (li.level > curLevel) {
            html += `<${li.type}>`; listStack.push({ type: li.type });
          } else if (li.level < curLevel) {
            closeListsTo(li.level);
          }
          const curType = listStack[listStack.length - 1].type;
          if (curType !== li.type) {
            html += `</${curType}><${li.type}>`;
            listStack[listStack.length - 1].type = li.type;
          }
        }
        html += `<li>${content}</li>`;
        continue;
      }

      closeListsTo(-1); while (listStack.length) { html += `</${listStack.pop().type}>`; }
      if (h) html += `<${h}>${content}</${h}>`;
      else html += `<p>${content}</p>`;
    }

    closeListsTo(-1); while (listStack.length) { html += `</${listStack.pop().type}>`; }
    return sanitizeHTML(html);
  };

  const getParagraphs = (root) => [...root.querySelectorAll('p,h1,h2,h3,h4,ul,ol')];
  const getText = (el) => (el.textContent || '').replace(/\u00a0/g, ' ').trim();
  const pullLabeled = (blocks, labelRegex) => {
    for (let i = 0; i < blocks.length; i++) {
      const t = getText(blocks[i]), m = t.match(labelRegex);
      if (m) {
        const after = t.replace(labelRegex, '').trim();
        if (after) return after;
        const next = blocks[i + 1] && blocks[i + 1].tagName === 'P' ? getText(blocks[i + 1]) : '';
        return next || '';
      }
    }
    return '';
  };

  const cleanUrlAlias = (input) => {
    let s = (input || '').replace(/^[A-Z]{2}:\s*/, '').trim();
    s = s.replace(/^https?:\/\/[^/]+/, '');
    s = s.replace(/^\/(nl|fr|en)(?=\/)/i, '');
    s = s.replace(/\s*-\s*/g, '-');
    s = s.replace(/\s+/g, '');
    if (s && s[0] !== '/') s = '/' + s;
    return s;
  };

  // ===== PHASE 2: Format Detection =====
  const detectDocxFormat = (html) => {
    const hasStandardMarkers = /(?:URL\s*:|H1\s*:|Intro\s*\(H3\)|Text\s*block)/i.test(html);
    const hasTemplateMarkers = /(?:Source\s*:|Article\s*category\s*:|\[COMPONENT\s*:)/i.test(html);
    // New: Check for Heading-based structure (H1 present, but no explicit Text Block markers)
    const hasHeadings = /<h1/i.test(html) && !/Text\s*block/i.test(html);

    if (hasTemplateMarkers || hasHeadings) {
      console.log('[v1-Phase2] Formato detectado: template (ou heading-based)');
      return 'template';
    }
    if (hasStandardMarkers) {
      console.log('[v1-Phase2] Formato detectado: standard');
      return 'standard';
    }
    console.log('[v1-Phase2] Formato detectado: unknown (usando standard como fallback)');
    return 'unknown';
  };

  const extractComponentsFromStructure = (html) => {
    const tmp = document.createElement('div');
    tmp.innerHTML = html;
    const components = [];
    let current = null;

    const flush = () => {
      if (current) {
        components.push(current);
        current = null;
      }
    };

    const nodes = Array.from(tmp.childNodes);
    let introContent = '';
    let inIntro = true;

    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      if (node.nodeType !== 1) continue;

      const tag = node.tagName;
      const text = node.textContent.trim();
      const hasImg = node.querySelector('img') || (tag === 'IMG');

      // Header detection (H2 or H3)
      if (/^H[23]$/.test(tag)) {
        flush();
        inIntro = false;

        // Look ahead for Image
        let next = nodes[i + 1];
        while (next && next.nodeType !== 1) next = nodes[i + 1 + (next === nodes[i + 1] ? 1 : 0)]; // simple skip? No, need index logic
        // Better: find next element sibling
        let sibling = node.nextElementSibling;

        const nextHasImg = sibling && (sibling.querySelector('img') || sibling.tagName === 'IMG');

        if (nextHasImg) {
          current = { type: 'c_sideimagetext', content: node.outerHTML, index: components.length, drupalType: 'c_sideimagetext', label: text.substring(0, 30) };
        } else {
          current = { type: 'c_text', content: node.outerHTML, index: components.length, drupalType: 'c_text', label: text.substring(0, 30) };
        }
        continue;
      }

      if (hasImg) {
        inIntro = false;
        if (!current) {
          current = { type: 'c_sideimagetext', content: '', index: components.length, drupalType: 'c_sideimagetext', label: 'Image Block' };
        } else if (current.type === 'c_text') {
          // Switch to sideimagetext if we encounter an image in a text block?
          // Or just treat as content?
          // If it's c_text, it might be a mistake if we didn't detect it earlier.
          // But let's keep it simple.
        }
        current.content += node.outerHTML;
        continue;
      }

      if (inIntro) {
        // Check if this is H1 or Meta, ignore
        if (tag === 'H1' || /^(Meta|OG|URL|Source)/i.test(text)) {
          // ignore
        } else {
          introContent += node.outerHTML;
        }
      } else {
        if (!current) {
          current = { type: 'c_text', content: '', index: components.length, drupalType: 'c_text', label: 'Text Block' };
        }
        current.content += node.outerHTML;
      }
    }
    flush();
    return { components, intro: introContent };
  };

  // ===== PHASE 2: Template Format Parser (with Components) =====
  const parseTemplateFormat = (html) => {
    const clean = sanitizeHTML(htmlFromClipboardOrText(html));
    const tmp = document.createElement('div');
    tmp.innerHTML = clean;

    // Extract title from H1 tag
    const h1Tag = tmp.querySelector('h1');
    let h1 = h1Tag ? getText(h1Tag) : '';
    if (h1 && !h1.match(/^(Source|Article category|Meta|SEO)/i)) {
      h1 = dequote(h1).substring(0, 255);
      console.log('[v1-Phase2] Título extraído de <h1>:', h1);
    }

    // Extract URL from Source: marker
    const blocks = getParagraphs(tmp);
    let urlAlias = '';
    for (const block of blocks) {
      const text = getText(block);
      const sourceMatch = text.match(/^Source\s*:\s*(.+)$/i);
      if (sourceMatch) {
        urlAlias = cleanUrlAlias(sourceMatch[1].trim());
        console.log('[v1-Phase2] URL extraído de Source:', urlAlias);
        break;
      }
    }

    // Extract SEO metadata
    const allText = tmp.textContent || '';
    const seoSectionMatch = allText.match(/SEO\s+METADATA([\s\S]*?)(?:\[COMPONENT\s*:|$)/i);
    let metaTitle = '', metaDesc = '';

    if (seoSectionMatch) {
      const seoContent = seoSectionMatch[1];
      const metaTitleMatch = seoContent.match(/Meta\s*title\s*:\s*([^\n]+)/i);
      const metaDescMatch = seoContent.match(/Meta\s*description\s*:\s*([^\n]+)/i);
      metaTitle = metaTitleMatch ? dequote(metaTitleMatch[1].trim()) : '';
      metaDesc = metaDescMatch ? dequote(metaDescMatch[1].trim()) : '';
      console.log('[v1-Phase2] SEO Metadata extraído:', { metaTitle, metaDesc });
    }

    const ogTitle = metaTitle;
    const ogDesc = metaDesc;

    // Extract components
    let components = extractComponents(clean);
    let intro = '';

    if (!components) {
      console.log('[v1-Phase2] No [COMPONENT] markers found. Trying structure-based extraction.');
      const struct = extractComponentsFromStructure(clean);
      components = struct.components;
      intro = struct.intro;
    } else {
      // Legacy Intro extraction for explicit markers
      let foundH1 = false;
      for (const block of blocks) {
        if (block.tagName === 'H1') {
          foundH1 = true;
          continue;
        }
        if (foundH1 && block.tagName === 'P') {
          const text = (block.textContent || '').trim();
          if (text && !text.match(/^(Source|Article category|SEO METADATA|\[COMPONENT)/i)) {
            intro = `<h3>${block.innerHTML}</h3>`;
            break;
          }
        }
      }
    }

    // If components found, use them; otherwise fallback to t1
    let t1 = '', t2 = '', t3 = '';
    if (components && components.length > 0) {
      console.log('[v1-Phase2] Usando componentes estruturados');
    } else {
      const contentBlocks = blocks.filter(b => {
        const text = (b.textContent || '').trim();
        return text && !text.match(/^(Source|Article category|Meta|SEO METADATA|URL\s*:)/i);
      });
      t1 = contentBlocks.map(b => b.outerHTML).join('');
    }

    console.log('[v1-Phase2] Template format parsed:', {
      h1, metaTitle, urlAlias,
      componentsCount: components?.length || 0,
      category: null
    });

    return {
      clean, h1, intro, t1, t2, t3,
      imgBlocks: [],
      metaTitle, metaDesc, ogTitle, ogDesc, urlAlias,
      components: components || [],
      category: null
    };
  };

  // ===== Standard Format Parser (original logic) =====
  const parseStandardFormat = (html) => {
    const clean = sanitizeHTML(htmlFromClipboardOrText(html));
    const tmp = document.createElement('div'); tmp.innerHTML = clean;
    const blocks = getParagraphs(tmp).filter(n => {
      const s = getText(n);
      if (/^Add a block with the following info here/i.test(s)) return false;
      if (/^(Voor meer informação|Voor meer informatie|En savoir plus)$/i.test(s)) return false;
      return true;
    });

    // H1 e fallback por marcador "H1:"
    const h1Tag = tmp.querySelector('h1');
    let h1 = h1Tag ? getText(h1Tag) : '';
    if (!h1) h1 = pullLabeled(blocks, /^\s*H1\s*:?\s*/i);

    // Metas
    const metaTitle = pullLabeled(blocks, /^Meta\s*title\s*:\s*/i);
    const metaDesc = pullLabeled(blocks, /^Meta\s*description\s*:\s*/i);
    const ogTitle = pullLabeled(blocks, /^(OG|Og)\s*title\s*:\s*/i);
    const ogDesc = pullLabeled(blocks, /^(OG|Og)\s*description\s*:\s*/i);
    const urlFull = pullLabeled(blocks, /^URL\s*:\s*/i);
    const urlAlias = urlFull ? cleanUrlAlias(urlFull) : '';

    // Normaliza / remove aspas e aplica fallback de OG
    h1 = dequote(h1);
    const _metaTitle = dequote(metaTitle);
    const _metaDesc = dequote(metaDesc);
    let _ogTitle = dequote(ogTitle) || _metaTitle;
    let _ogDesc = dequote(ogDesc) || _metaDesc;
    const _urlAlias = urlAlias || '';

    // Prepara editor
    $ed.innerHTML = clean;

    // Alt-tags + blocos sugeridos
    const htmlBlocks = blocks.map(n => n.outerHTML);
    const texts = [], alts = [];
    for (let i = 0; i < htmlBlocks.length; i++) {
      const plain = htmlBlocks[i].replace(/<[^>]+>/g, '').trim();
      const m = plain.match(/^Alt-tag\s*:\s*(.+)$/i);
      if (m) {
        const summary = [];
        for (let j = i + 1; j < htmlBlocks.length && summary.length < 4; j++) {
          const s = htmlBlocks[j].replace(/<[^>]+>/g, '').trim();
          if (!s || /^Alt-tag\s*:/i.test(s) || /^Meta |^(OG|Og)\s+/i.test(s) || /^URL\s*:/i.test(s)) break;
          summary.push(htmlBlocks[j]);
          if (summary.join('').replace(/<[^>]+>/g, '').length >= 480) break;
        }
        alts.push({ alt: m[1].trim(), summary: summary.slice(0, 2).join('') });
      } else texts.push(htmlBlocks[i]);
    }
    const intro = texts.length ? `<h3>${texts[0].replace(/^<p>|<\/p>$/g, '')}<\/h3>` : '';
    const rest = texts.slice(1);
    const parts = (arr, n) => arr.length ? Array.from({ length: n }, (_, k) => arr.slice(Math.ceil(arr.length / n) * k, Math.ceil(arr.length / n) * (k + 1)).join('')) : Array(n).fill('');
    const [t1, t2, t3] = parts(rest, 3);

    return { clean, h1, intro, t1, t2, t3, imgBlocks: alts.slice(0, 2), metaTitle: _metaTitle, metaDesc: _metaDesc, ogTitle: _ogTitle, ogDesc: _ogDesc, urlAlias: _urlAlias };
  };

  // ===== PHASE 3: Auto-Tagging Logic (Minimal Strategy) =====
  // Apenas marca Alt-tags como Image+Text e primeiro bloco de texto
  const autoTagComponents = () => {
    const root = document.createElement('div');
    root.innerHTML = $ed.innerHTML;
    const nodes = Array.from(root.childNodes);
    let out = '';
    let imageTextCount = 0;
    let firstTextBlockMarked = false;
    let afterH1 = false;

    for (let i = 0; i < nodes.length; i++) {
      const node = nodes[i];
      if (node.nodeType !== 1) {
        out += node.textContent;
        continue;
      }

      const tag = node.tagName;
      const text = node.textContent?.trim() || '';

      // H1 - marca que passou
      if (tag === 'H1') {
        afterH1 = true;
        out += node.outerHTML;
        continue;
      }

      // Skip Meta/Source/etc
      if (/^(Meta|OG|URL|Source|Article category|EN\s|BE-|Gidsen voor)/i.test(text)) {
        out += node.outerHTML;
        continue;
      }

      // **REGRA 1: Alt-tag sempre marca Image+Text**
      if (/^Alt-tag:/i.test(text)) {
        imageTextCount++;
        out += `<p><strong>[COMPONENT: Image+Text ${imageTextCount}]</strong></p>`;
        out += node.outerHTML;
        continue;
      }

      // **REGRA 2: Primeiro parágrafo substancial após H1 = Text Block 1**
      if (afterH1 && !firstTextBlockMarked && tag === 'P' && text.length > 50) {
        out += `<p><strong>[COMPONENT: Text Block 1]</strong></p>`;
        out += node.outerHTML;
        firstTextBlockMarked = true;
        continue;
      }

      // Resto do conteúdo sem marcadores
      out += node.outerHTML;
    }

    $ed.innerHTML = out;

    const textBlocks = firstTextBlockMarked ? 1 : 0;
    log(`Auto-Tag (minimal): ${textBlocks} Text Block + ${imageTextCount} Image+Text marcados. Use "Analisar" para divisão completa em blocos.`);
  };

  // ===== PHASE 2: Main Parser with Format Detection =====
  const parseArticle = (html) => {
    const format = detectDocxFormat(html);

    if (format === 'template') {
      return parseTemplateFormat(html);
    } else {
      // 'standard' or 'unknown' -> use original logic
      return parseStandardFormat(html);
    }
  };

  // ===== PHASE 2: Component Type Mapping =====
  const COMPONENT_TYPE_MAPPING = {
    'Text Block 1': 'c_text',
    'Text Block 2': 'c_text',
    'Text Block 3': 'c_text',
    'Image+Text 1': 'c_sideimagetext',
    'Image+Text 2': 'c_sideimagetext',
    'Image+Text 3': 'c_sideimagetext',
    'Contact Us Small': 'c_signposting',
    'Image Gallery': 'c_media',
    'Product Recommendations': 'c_products_list',
    'Tabbed Content': 'c_tabbed_content',
    'Accordion': 'c_accordion',
    'Brand Carousel': 'c_brand_carousel',
    'Document': 'c_document'
  };

  // ===== PHASE 2: Extract Components from template.docx =====
  const extractComponents = (html) => {
    const components = [];
    const componentRegex = /\[COMPONENT:\s*([^\]]+)\]/gi;
    const matches = [...html.matchAll(componentRegex)];
    if (matches.length === 0) return null;

    matches.forEach((match, index) => {
      const type = match[1].trim();
      const startIndex = match.index + match[0].length;
      const nextMatch = matches[index + 1];
      const endIndex = nextMatch ? nextMatch.index : html.length;
      const rawContent = html.substring(startIndex, endIndex);

      const tmp = document.createElement('div');
      tmp.innerHTML = rawContent;
      const blocks = [...tmp.querySelectorAll('p,h1,h2,h3,h4,ul,ol')].filter(el => {
        const text = (el.textContent || '').trim();
        return text && !text.match(/^(Source|Article category|Meta|SEO METADATA|URL\s*:|\[COMPONENT)/i);
      });

      const content = blocks.map(b => b.outerHTML).join('');
      const drupalType = COMPONENT_TYPE_MAPPING[type] || 'c_text';

      if (drupalType === 'c_text' && !COMPONENT_TYPE_MAPPING[type]) {
        console.warn(`[v1-Phase2] Componente não mapeado: "${type}", usando c_text como fallback`);
      }

      components.push({
        type: type,
        content: content,
        rawHtml: rawContent,
        drupalType: drupalType
      });
    });

    console.log(`[v1-Phase2] ${components.length} componente(s) extraído(s)`);
    return components.length > 0 ? components : null;
  };

  // ===== PHASE 2: Extract Category from template.docx =====
  const extractCategory = (html) => {
    const tmp = document.createElement('div');
    tmp.innerHTML = html || '';
    const blocks = [...tmp.querySelectorAll('p,h1,h2,h3,h4')];
    const getText = (el) => (el.textContent || '').replace(/\u00a0/g, ' ').trim();

    for (const block of blocks) {
      const text = getText(block);
      const categoryMatch = text.match(/^Article\s*category\s*:\s*([^-]+)\s*-\s*(.+)$/i);
      if (categoryMatch) {
        const category = {
          name: categoryMatch[1].trim(),
          url: categoryMatch[2].trim()
        };
        console.log('[v1-Phase2] Categoria extraída:', category.name);
        return category;
      }
    }
    return null;
  };

  // ===== PHASE 2: AJAX Helper Functions =====

  // Wait for Drupal AJAX operations to complete
  const waitForAjax = async (timeout = 15000) => {
    const start = Date.now();

    // 1. Wait for potential AJAX start (stabilization)
    await new Promise(resolve => setTimeout(resolve, 200));

    while (Date.now() - start < timeout) {
      if (window.jQuery) {
        if (window.jQuery.active === 0) {
          // Double check: wait a bit more to ensure it's really done
          await new Promise(resolve => setTimeout(resolve, 100));
          if (window.jQuery.active === 0) return true;
        }
      } else {
        // Fallback if jQuery not present (shouldn't happen in Drupal admin)
        const ajaxActive = document.querySelector('.ajax-progress') !== null;
        if (!ajaxActive) return true;
      }
      await new Promise(resolve => setTimeout(resolve, 100));
    }

    console.warn('[v1-Phase2] AJAX timeout after', timeout, 'ms');
    return false;
  };

  // Get the latest (highest index) component in the paragraphs container
  const getLatestComponentIndex = () => {
    const wrapper = document.querySelector('[data-drupal-selector="edit-field-article-lp-components-wrapper"]');
    if (!wrapper) return -1;

    // Find all paragraph items
    const items = wrapper.querySelectorAll('[id^="field-article-lp-components-"][id$="-item-wrapper"]');
    if (items.length === 0) return -1;

    // Extract indices and find max
    const indices = Array.from(items).map(item => {
      const match = item.id.match(/field-article-lp-components-(\d+)-item-wrapper/);
      return match ? parseInt(match[1], 10) : -1;
    }).filter(idx => idx >= 0);

    const maxIndex = Math.max(...indices);
    console.log('[v1-Phase2] Latest component index:', maxIndex);
    return maxIndex;
  };

  // Get the "Add more" button ID for a specific component type
  const getAddMoreButtonId = (drupalType) => {
    // Map internal types to actual Drupal button IDs (with hyphens, not underscores)
    const typeMapping = {
      'c_text': 'c-text',
      'c_sideimagetext': 'c-sideimagetext-ttt',
      'c_signposting': 'c-signposting',
      'c_media': 'c-media',
      'c_products_list': 'c-products-list',
      'c_tabbed_content': 'c-tabbed-content',
      'c_accordion': 'accordion',
      'c_brand_carousel': 'c-brand-carousel',
      'c_document': 'c-document'
    };

    const mappedType = typeMapping[drupalType] || drupalType;

    // Pattern: field-article-lp-components-{type}-add-more--{unique-suffix}
    // Use querySelector to find button that starts with the pattern
    const selector = `input[id^="field-article-lp-components-${mappedType}-add-more"]`;
    const button = document.querySelector(selector);

    if (button) {
      console.log('[v1-Phase2.5] Found add button:', button.id);
      return button.id;
    }

    console.warn('[v1-Phase2.5] Add button not found for type:', drupalType, '(mapped to:', mappedType + ')');
    return null;
  };

  // ===== PHASE 2: Component Creation Logic =====

  // Check if a component exists at a specific index
  const componentExists = (index) => {
    const wrapper = document.getElementById(`field-article-lp-components-${index}-item-wrapper`);
    return wrapper !== null;
  };

  // Create Drupal components from extracted component data
  const createDrupalComponents = async (components, logs) => {
    if (!components || components.length === 0) {
      logs.push('[v1-Phase2] Nenhum componente para criar');
      return [];
    }

    console.log('[v1-Phase2] Verificando e criando componentes...');
    const processedComponents = [];

    for (let i = 0; i < components.length; i++) {
      const component = components[i];
      const { drupalType, type } = component;
      const targetIndex = i; // Assume 1:1 mapping based on order

      // 1. Validate if block already exists
      if (componentExists(targetIndex)) {
        logs.push(`ℹ️ Componente ${i} (${type}) já existe. Pulando criação.`);
        processedComponents.push({
          ...component,
          index: targetIndex
        });
        continue;
      }

      // 2. If block doesn't exist, add it
      logs.push(`[v1-Phase2] Componente ${i} ausente. Criando...`);

      // Find "Add more" button for this component type
      const buttonId = getAddMoreButtonId(drupalType);
      if (!buttonId) {
        logs.push(`❌ Botão "Add more" não encontrado para ${drupalType}`);
        continue;
      }

      const button = document.getElementById(buttonId);
      if (!button) {
        logs.push(`❌ Botão não encontrado: ${buttonId}`);
        continue;
      }

      // Handle Dropbutton: Click toggle if present
      const dropWrapper = button.closest('.dropbutton-wrapper');
      if (dropWrapper) {
        const toggle = dropWrapper.querySelector('.dropbutton-toggle button');
        if (toggle && toggle.offsetParent !== null) { // Check if visible
          console.log('[v1-Phase2] Opening dropbutton...');
          toggle.click();
          await new Promise(r => setTimeout(r, 600)); // Increased wait for UI expansion
        }
      }

      logs.push(`🔄 Adicionando componente ${i + 1}/${components.length}: ${type} (${drupalType})`);

      // Robust Click Sequence
      try {
        button.scrollIntoView({ block: 'center', inline: 'center' });
        button.focus();
        // Dispatch events to ensure Drupal catches the interaction
        button.dispatchEvent(new MouseEvent('mousedown', { bubbles: true, cancelable: true, view: window }));
        button.dispatchEvent(new MouseEvent('mouseup', { bubbles: true, cancelable: true, view: window }));
        button.click();
      } catch (e) {
        console.error('Click error:', e);
        logs.push(`⚠️ Erro ao clicar: ${e.message}`);
        // Fallback simple click
        button.click();
      }

      // Wait for AJAX to complete
      const ajaxSuccess = await waitForAjax(15000);
      if (!ajaxSuccess) {
        logs.push(`⚠️ AJAX timeout para componente ${type}`);
        continue;
      }

      // 3. Validate if block exists (post-creation)
      if (componentExists(targetIndex)) {
        logs.push(`✅ Componente ${i} criado com sucesso`);
        processedComponents.push({
          ...component,
          index: targetIndex
        });
      } else {
        logs.push(`⚠️ Novo componente ${i} não detectado após AJAX`);
      }

      // Small delay to ensure DOM stability
      await new Promise(r => setTimeout(r, 500));
    }
    console.log('[v1-Phase2] Processamento de componentes concluído:', processedComponents.length);
    return processedComponents;
  };

  // Set position for Side Image + Text component
  const setSideImagePosition = async (index, position, logs) => {
    // position: 'left' or 'right'
    const wrapper = document.getElementById(`field-article-lp-components-${index}-item-wrapper`);
    if (!wrapper) return;

    // Try to find radio buttons with value 'left'/'right'
    const radios = Array.from(wrapper.querySelectorAll('input[type="radio"]'));
    let target = radios.find(r => r.value.toLowerCase() === position);

    if (target) {
      if (!target.checked) {
        target.click();
        logs.push(`✅ Posição ${position} definida para componente ${index}`);
      } else {
        logs.push(`ℹ️ Posição já era ${position} para componente ${index}`);
      }
    } else {
      logs.push(`⚠️ Campo de posição (${position}) não encontrado para componente ${index}`);
    }
  };

  // Fill content into a specific component  
  const fillComponentContent = async (componentIndex, content, logs) => {
    if (!content || content.trim() === '') {
      logs.push(`[v1-Phase2] Componente ${componentIndex}: conteúdo vazio, pulando`);
      return false;
    }

    // Try to find CKEditor field within this component
    // Pattern: field-article-lp-components-{index}-subform-field-text-0-value
    const possibleSelectors = [
      `#field-article-lp-components-${componentIndex}-subform-field-text-0-value`,
      `#field-article-lp-components-${componentIndex}-subform-field-content-0-value`,
      `#field-article-lp-components-${componentIndex}-subform-field-body-0-value`
    ];

    for (const selector of possibleSelectors) {
      const field = document.querySelector(selector);
      if (field) {
        console.log('[v1-Phase2] Preenchendo componente', componentIndex, 'com', content.length, 'caracteres');
        await setRichText(selector, content, logs);
        return true;
      }
    }

    logs.push(`⚠️ Campo de texto não encontrado no componente ${componentIndex}`);
    return false;
  };

  // ===== PHASE 2.5: Smart Component Creation for Standard Format =====

  // Map standard content blocks to Drupal components
  const mapStandardToComponents = (intro, t1, t2, t3, i1, i2) => {
    const components = [];

    // Intro → c_text (index 0)
    if (intro?.innerHTML?.trim()) {
      components.push({ index: 0, type: 'c_text', content: intro.innerHTML, label: 'Intro' });
    }

    // Text Block 1 → c_text (index 1)
    if (t1?.innerHTML?.trim()) {
      components.push({ index: 1, type: 'c_text', content: t1.innerHTML, label: 'Text Block 1' });
    }

    // Image+Text 1 → c_sideimagetext (index 2)
    if (i1?.innerHTML?.trim()) {
      components.push({ index: 2, type: 'c_sideimagetext', content: i1.innerHTML, label: 'Image+Text 1' });
    }

    // Text Block 2 → c_text (index 3)
    if (t2?.innerHTML?.trim()) {
      components.push({ index: 3, type: 'c_text', content: t2.innerHTML, label: 'Text Block 2' });
    }

    // Image+Text 2 → c_sideimagetext (index 4)
    if (i2?.innerHTML?.trim()) {
      components.push({ index: 4, type: 'c_sideimagetext', content: i2.innerHTML, label: 'Image+Text 2' });
    }

    // Text Block 3 → c_text (index 5)
    if (t3?.innerHTML?.trim()) {
      components.push({ index: 5, type: 'c_text', content: t3.innerHTML, label: 'Text Block 3' });
    }

    return components;
  };

  // Create missing components in order
  const createMissingComponents = async (neededComponents, logs) => {
    const missing = neededComponents.filter(comp => !componentExists(comp.index));

    if (missing.length === 0) {
      logs.push('[v1-Phase2.5] Todos os componentes já existem ✅');
      return true;
    }

    logs.push('');
    logs.push(`[v1-Phase2.5] 🔧 Criando ${missing.length} componente(s) faltante(s)...`);

    for (const comp of missing) {
      const buttonId = getAddMoreButtonId(comp.type);
      if (!buttonId) {
        logs.push(`❌ Botão não encontrado para ${comp.type}`);
        continue;
      }

      const button = document.getElementById(buttonId);
      if (!button) {
        logs.push(`❌ Botão ${buttonId} não existe`);
        continue;
      }

      // Handle Dropbutton: Click toggle if present
      const dropWrapper = button.closest('.dropbutton-wrapper');
      if (dropWrapper) {
        const toggle = dropWrapper.querySelector('.dropbutton-toggle button');
        if (toggle && toggle.offsetParent !== null) { // Check if visible
          console.log('[v1-Phase2.5] Opening dropbutton...');
          toggle.click();
          await new Promise(r => setTimeout(r, 600)); // Increased wait for UI expansion
        }
      }

      logs.push(`🔄 Criando ${comp.label} (index ${comp.index}, tipo ${comp.type})...`);

      // Robust Click Sequence
      try {
        button.scrollIntoView({ block: 'center', inline: 'center' });
        button.focus();
        // Dispatch events to ensure Drupal catches the interaction
        button.dispatchEvent(new MouseEvent('mousedown', { bubbles: true, cancelable: true, view: window }));
        button.dispatchEvent(new MouseEvent('mouseup', { bubbles: true, cancelable: true, view: window }));
        button.click();
      } catch (e) {
        console.error('Click error:', e);
        logs.push(`⚠️ Erro ao clicar: ${e.message}`);
        // Fallback simple click
        button.click();
      }

      const ajaxOk = await waitForAjax(15000);
      if (!ajaxOk) {
        logs.push(`⚠️ AJAX timeout para ${comp.label}`);
        continue;
      }

      // Verify creation
      if (componentExists(comp.index)) {
        logs.push(`✅ ${comp.label} criado com sucesso`);
      } else {
        logs.push(`⚠️ ${comp.label} não detectado após AJAX`);
      }

      // Small delay between creations
      await new Promise(r => setTimeout(r, 500));
    }

    return true;
  };

  // === Markers → Blocos (aceita ambos formatos)
  const extractByMarkers = (html) => {
    const tmp = document.createElement('div'); tmp.innerHTML = html;
    const blocks = getParagraphs(tmp);

    // Procura marcadores explícitos (aceita formato antigo e novo)
    const findBlock = (regexArray) => {
      let content = '';
      let capturing = false;
      for (const b of blocks) {
        const txt = getText(b);

        // Verifica se é um dos marcadores procurados
        if (regexArray.some(regex => regex.test(txt))) {
          capturing = true;
          continue; // Pula a linha do marcador
        }

        if (capturing) {
          // Se encontrar outro marcador, para
          if (/^(Text\s*[Bb]lock|Image\+Text|Intro|H1|Meta|URL|Source|Article|\[COMPONENT)/i.test(txt)) {
            break;
          }
          content += b.outerHTML;
        }
      }
      return content;
    };

    // Tenta extrair por marcadores conhecidos (formato antigo OU novo)
    const intro = findBlock([
      /^Intro\s*\(H3\)/i,
      /^\[COMPONENT:\s*Intro\]/i
    ]);

    const t1 = findBlock([
      /^Text\s*[Bb]lock\s*1/i,
      /^\[COMPONENT:\s*Text\s*Block\s*1\]/i
    ]);

    const i1 = findBlock([
      /^Image\+Text\s*1/i,
      /^\[COMPONENT:\s*Image\+Text\s*1\]/i
    ]);

    const t2 = findBlock([
      /^Text\s*[Bb]lock\s*2/i,
      /^\[COMPONENT:\s*Text\s*Block\s*2\]/i
    ]);

    const i2 = findBlock([
      /^Image\+Text\s*2/i,
      /^\[COMPONENT:\s*Image\+Text\s*2\]/i
    ]);

    const t3 = findBlock([
      /^Text\s*[Bb]lock\s*3/i,
      /^\[COMPONENT:\s*Text\s*Block\s*3\]/i
    ]);

    // Se encontrou algo, retorna
    if (intro || t1 || i1 || t2 || i2 || t3) {
      console.log('[v1-Phase3] Extração por marcadores explícitos realizada');
      return { intro, t1, t2, t3, i1, i2 };
    }

    // Fallback: Retorna null para usar a lógica padrão (divisão sequencial)
    return null;
  };

  // ===== CKEditor 5 Helpers =====
  const getCKE5Registry = () => {
    if (window.Drupal?.CKEditor5Instances) return window.Drupal.CKEditor5Instances;
    return null;
  };

  const findCKInstance = (selector) => {
    const registry = getCKE5Registry();
    if (!registry) return null;
    // Tenta encontrar pela chave exata ou ID
    if (registry.has(selector)) return registry.get(selector);
    // Tenta encontrar pelo elemento DOM
    const el = document.querySelector(selector);
    if (el) {
      // Itera sobre as instâncias para ver se alguma corresponde ao elemento
      for (const [key, instance] of registry) {
        if (instance.sourceElement === el) return instance;
      }
    }
    return null;
  };

  const setRichText = async (selector, html, logs) => {
    const instance = findCKInstance(selector);
    if (instance) {
      instance.setData(html);
      logs.push(`✅ CKEditor definido para ${selector}`);
    } else {
      // Fallback para textarea simples (caso CKEditor não esteja carregado ou seja campo simples)
      const el = document.querySelector(selector);
      if (el) {
        el.value = html;
        el.dispatchEvent(new Event('input', { bubbles: true }));
        el.dispatchEvent(new Event('change', { bubbles: true }));
        logs.push(`✅ Valor definido (fallback) para ${selector}`);
      } else {
        logs.push(`❌ Campo não encontrado: ${selector}`);
      }
    }
  };

  const setInput = (selector, val, logs) => {
    const el = document.querySelector(selector);
    if (el) {
      el.value = val || '';
      el.dispatchEvent(new Event('input', { bubbles: true }));
      el.dispatchEvent(new Event('change', { bubbles: true }));
      logs.push(`✅ Input definido para ${selector}`);
    } else {
      logs.push(`❌ Input não encontrado: ${selector}`);
    }
  };

  // ===== Bold → Headings Logic =====
  const resolveSel = (sel) => {
    if (typeof sel === 'string') return document.querySelector(sel);
    return sel; // element
  };

  const openAllParagraphs = async () => {
    const buttons = document.querySelectorAll('input.paragraphs-icon-button-edit, input[name*="subform_field_"][value="Edit"]');
    for (const btn of buttons) {
      btn.click();
      await new Promise(r => setTimeout(r, 300));
    }
  };

  const norm = s => s.replace(/\s+/g, ' ').trim();

  // Coleta itens em negrito (<strong> ou <b> ou style="font-weight:bold")
  const boldItems = []; // { text, element, contextBlock }

  const isBoldNode = (n) => {
    if (n.nodeType !== 1) return false;
    const tag = n.tagName.toUpperCase();
    if (tag === 'STRONG' || tag === 'B') return true;
    if (n.style && (n.style.fontWeight === 'bold' || parseInt(n.style.fontWeight) >= 700)) return true;
    return false;
  };

  // Verifica se entre dois nós só existe espaço/pontuação
  const isBetweenOk = (n1, n2) => {
    let curr = n1.nextSibling;
    while (curr && curr !== n2) {
      if (curr.nodeType === 3) {
        if (/[^ \t\r\n.,:;\-]/.test(curr.textContent)) return false;
      } else if (curr.nodeType === 1) {
        if (curr.tagName === 'BR') { /* ok */ }
        else return false;
      }
      curr = curr.nextSibling;
    }
    return true;
  };

  const collectBoldClusters = (root) => {
    const clusters = [];
    const walk = (node) => {
      for (let n = node.firstChild; n; n = n.nextSibling) {
        if (n.nodeType === 1) {
          if (isBoldNode(n)) {
            // Tenta agrupar com o último cluster se estiver próximo
            const last = clusters[clusters.length - 1];
            if (last && last.parent === node && isBetweenOk(last.nodes[last.nodes.length - 1], n)) {
              last.nodes.push(n);
              last.text += ' ' + n.textContent;
            } else {
              clusters.push({ nodes: [n], parent: node, text: n.textContent });
            }
          } else {
            walk(n);
          }
        }
      }
    };
    walk(root);
    return clusters;
  };

  const findBoldSentences = (rootElement) => {
    const root = resolveSel(rootElement);
    if (!root) return [];
    const clusters = collectBoldClusters(root);
    // Filtra clusters que parecem títulos (curtos, sem ponto final no meio, etc)
    return clusters.map((c, idx) => {
      const txt = norm(c.text);
      // Heurística: se for muito longo (> 150 chars), provavelmente não é título
      if (txt.length > 150) return null;
      return { id: idx, text: txt, nodes: c.nodes, parent: c.parent };
    }).filter(Boolean);
  };

  const renderBoldList = (list) => {
    $boldList.innerHTML = '';
    if (!list.length) {
      $boldList.innerHTML = '<div style="padding:10px;color:#888">Nenhum negrito relevante encontrado.</div>';
      return;
    }
    list.forEach(item => {
      const div = document.createElement('div');
      div.className = 'bolditem';
      div.innerHTML = `
        <div class="txt">"${esc(item.text)}"</div>
        <select data-id="${item.id}">
          <option value="">(Ignorar)</option>
          <option value="h2">Converter p/ H2</option>
          <option value="h3">Converter p/ H3</option>
          <option value="h4">Converter p/ H4</option>
        </select>
      `;
      $boldList.appendChild(div);
    });
  };

  const buildHeadingFromRange = (nodes, level) => {
    // Cria o elemento Hx
    const h = document.createElement(level);
    // Pega o texto combinado dos nós
    const txt = nodes.map(n => n.textContent).join(' ');
    h.textContent = txt;
    return h;
  };

  const replaceClusterWithHeading = (cluster, level) => {
    // A estratégia: inserir o Hx antes do primeiro nó, e remover os nós originais (e nós de texto/br entre eles)
    const first = cluster.nodes[0];
    const last = cluster.nodes[cluster.nodes.length - 1];
    const parent = cluster.parent;

    // Se o pai for um <p> e só tiver isso, substituímos o <p> inteiro
    const parentText = parent.textContent.trim();
    const clusterText = cluster.nodes.map(n => n.textContent).join('').trim();
    // Comparação aproximada (ignorando espaços)
    if (parent.tagName === 'P' && norm(parentText) === norm(clusterText)) {
      const h = document.createElement(level);
      h.innerHTML = parent.innerHTML; // Mantém links ou outros inlines se houver?
      // Melhor: recriar limpo ou manter HTML interno dos bolds?
      // Simplificação: pega o texto dos bolds.
      h.textContent = clusterText;
      parent.replaceWith(h);
      return;
    }

    // Caso contrário, é inline no meio de um texto (estranho para título, mas ok)
    // Ou é o início de um parágrafo.
    // Vamos quebrar o parágrafo?
    // Abordagem simples: substituir os nós bold pelo Hx (o que é inválido HTML dentro de P, mas o browser corrige fechando o P)
    // Vamos fazer o "split" do parágrafo se necessário.

    // Para simplificar neste script: substituímos os nós por um span temporário, pegamos o HTML do pai, e corrigimos?
    // Não, muito complexo.
    // Vamos apenas substituir os nós bold pelo Hx e deixar o browser lidar com a quebra de bloco.
    const h = document.createElement(level);
    h.textContent = clusterText;

    parent.insertBefore(h, first);

    // Remove os nós originais e o que estiver entre eles
    let curr = first;
    while (curr) {
      const next = curr.nextSibling;
      curr.remove();
      if (curr === last) break;
      curr = next;
    }
  };

  const convertBoldInRoot = (root, conversions) => {
    // conversions: { id: 'h2' }
    const clusters = findBoldSentences(root); // Recalcula pois índices mudam? Não, usamos referências de nós se possível.
    // Mas como o DOM muda, melhor ter cuidado.
    // Vamos usar os clusters originais se o DOM não mudou drasticamente.
    // Ou melhor: iterar reverso para não invalidar índices anteriores?
    // As conversões vêm do UI, baseadas nos IDs gerados pelo `findBoldSentences` anterior.
    // Precisamos re-encontrar ou confiar que os nós ainda estão lá.

    // Vamos usar a lista `currentBoldList` salva no escopo global ou recriar?
    // O ideal é que `findBoldSentences` retorne objetos com referências DOM vivas.

    // Aplicar conversões
    Object.entries(conversions).forEach(([id, level]) => {
      if (!level) return;
      const item = currentBoldList.find(x => x.id == id);
      if (item) {
        replaceClusterWithHeading(item, level);
      }
    });
  };

  let currentBoldList = [];

  const applyBoldConversions = () => {
    const selects = $boldList.querySelectorAll('select');
    const map = {};
    selects.forEach(s => {
      if (s.value) map[s.dataset.id] = s.value;
    });

    // Aplica no Editor
    convertBoldInRoot($ed, map);

    // Aplica nos Blocos (Intro, T1, etc)
    const blocks = [$intro, $t1, $t2, $t3, $i1, $i2];
    blocks.forEach(b => convertBoldInRoot(b, map));

    log('Conversões de negrito aplicadas.');
    // Limpa a lista visual
    $boldList.innerHTML = '<div>Aplicado. Re-analise se necessário.</div>';
  };

  // Toolbar do Editor
  const onToolbarClick = (e) => {
    const btn = e.target.closest('button');
    if (!btn) return;
    const act = btn.dataset.act;
    if (act === 'md-to-editor') {
      const md = $md.value;
      if (!md.trim()) { alert('Cole Markdown na caixa acima primeiro.'); return; }
      $ed.innerHTML = markdownToHTML(md);
    }
  };
  wrap.querySelector('.toolbar').addEventListener('click', onToolbarClick);


  // ===== Main Logic =====
  const fillDrupal = async (mapping, meta) => {
    const logs = [];
    logs.push('Iniciando preenchimento...');

    // 1. Meta Tags
    if (meta.h1) {
      // Tenta preencher campos de título conhecidos
      await setInput('input[name="title[0][value]"]', meta.h1, logs); // Title padrão
      await setInput('input[name="field_article_internal_title[0][value]"]', meta.h1, logs); // Internal title
    }
    if (meta.metaTitle) await setInput('input[name="field_meta_tags[0][basic][title]"]', meta.metaTitle, logs);
    if (meta.metaDesc) await setInput('textarea[name="field_meta_tags[0][basic][description]"]', meta.metaDesc, logs);
    if (meta.ogTitle) await setInput('input[name="field_meta_tags[0][open_graph][og_title]"]', meta.ogTitle, logs);
    if (meta.ogDesc) await setInput('textarea[name="field_meta_tags[0][open_graph][og_description]"]', meta.ogDesc, logs);
    if (meta.urlAlias) await setInput('input[name="path[0][alias]"]', meta.urlAlias, logs);

    // 2. Componentes
    // Se temos componentes estruturados (do template.docx), usamos eles
    if (meta.components && meta.components.length > 0) {
      logs.push(`[v1-Phase2] Usando ${meta.components.length} componentes estruturados`);

      // Cria componentes faltantes
      const created = await createDrupalComponents(meta.components, logs);

      // Preenche conteúdo
      for (const comp of created) {
        await fillComponentContent(comp.index, comp.content, logs);

        // Se for Side Image + Text, define posição (padrão right se não especificado?)
        // A lógica de extração atual não detecta posição, então deixamos padrão ou alternamos?
        // Vamos deixar padrão por enquanto.
        if (comp.drupalType === 'c_sideimagetext') {
          // Exemplo: setSideImagePosition(comp.index, 'right', logs);
        }
      }
    } else {
      // Fallback para lógica padrão (Intro, T1, I1, etc)
      logs.push('[v1-Phase2] Usando lógica padrão (Intro, T1, I1...)');

      const intro = $intro.innerHTML;
      const t1 = $t1.innerHTML;
      const t2 = $t2.innerHTML;
      const t3 = $t3.innerHTML;
      const i1 = $i1.innerHTML;
      const i2 = $i2.innerHTML;

      const needed = mapStandardToComponents($intro, $t1, $t2, $t3, $i1, $i2);
      await createMissingComponents(needed, logs);

      // Preenche sequencialmente
      // Intro (0)
      if (intro.trim()) await fillComponentContent(0, intro, logs);

      // T1 (1)
      if (t1.trim()) await fillComponentContent(1, t1, logs);

      // I1 (2)
      if (i1.trim()) await fillComponentContent(2, i1, logs);

      // T2 (3)
      if (t2.trim()) await fillComponentContent(3, t2, logs);

      // I2 (4)
      if (i2.trim()) await fillComponentContent(4, i2, logs);

      // T3 (5)
      if (t3.trim()) await fillComponentContent(5, t3, logs);
    }

    return logs.join('\n');
  };

  // Event Listeners
  $model.onchange = () => {
    const k = $model.value;
    const m = MODELS[k];
    if (m) log('Modelo selecionado:', k, '\nURL:', m.url);
  };

  $docx.onchange = async () => {
    if (!$docx.files[0]) return;
    try {
      log('Lendo DOCX...');
      const html = await getDocxHTML($docx.files[0]);
      $ed.innerHTML = html;
      log('DOCX carregado no Editor. Clique em "Analisar" para distribuir nos blocos.');
    } catch (e) {
      console.error(e);
      log('Erro ao ler DOCX:', e.message);
    }
  };

  $sanitize.onclick = () => {
    const clean = sanitizeHTML($ed.innerHTML);
    $ed.innerHTML = clean;
    log('HTML sanitizado.');
  };

  $autotag.onclick = () => {
    autoTagComponents();
  };

  $analyze.onclick = () => {
    // Se tiver Markdown, converte e joga no Editor primeiro
    if ($md.value.trim()) {
      $ed.innerHTML = markdownToHTML($md.value);
    }

    const html = $ed.innerHTML;
    const res = parseArticle(html);

    // Distribui nos campos visuais
    $h1.innerText = res.h1;

    // Preview Meta
    $metaPreview.innerHTML = `
      <div><b>Meta Title:</b> ${esc(res.metaTitle)}</div>
      <div><b>Meta Desc:</b> ${esc(res.metaDesc)}</div>
      <div><b>OG Title:</b> ${esc(res.ogTitle)}</div>
      <div><b>OG Desc:</b> ${esc(res.ogDesc)}</div>
      <div><b>URL Alias:</b> ${esc(res.urlAlias)}</div>
      <div style="margin-top:6px;font-size:0.9em;color:#666">
        Componentes detectados: ${res.components.length}
        ${res.components.length ? ' (Modo Template)' : ' (Modo Standard)'}
      </div>
    `;

    // Armazena meta completo no dataset para uso no Fill
    $log.dataset.meta = JSON.stringify(res);

    // Preenche blocos visuais (apenas para referência visual, o Fill usa o objeto 'res')
    $intro.innerHTML = res.intro;
    $t1.innerHTML = res.t1;
    $t2.innerHTML = res.t2;
    $t3.innerHTML = res.t3;

    // Para Image+Text, se veio do standard parser, temos imgBlocks
    if (res.imgBlocks && res.imgBlocks.length) {
      $i1.innerHTML = res.imgBlocks[0]?.summary || '';
      $i2.innerHTML = res.imgBlocks[1]?.summary || '';
    } else {
      // Se veio do template parser, os componentes já estão em res.components
      // Não precisamos preencher i1/i2 visualmente se for template mode, 
      // mas podemos tentar mostrar algo se houver c_sideimagetext
      $i1.innerHTML = '(Ver componentes)';
      $i2.innerHTML = '(Ver componentes)';
    }

    // Scan de Bolds
    currentBoldList = findBoldSentences($ed);
    renderBoldList(currentBoldList);
    if (currentBoldList.length) {
      $boldList.closest('details').open = true;
    }

    log('Análise concluída. Revise os blocos e clique em "Preencher Drupal".');
  };

  $extract.onclick = () => {
    // Extrai manualmente do Editor para os blocos usando marcadores explícitos (se houver)
    const html = $ed.innerHTML;
    const parts = extractByMarkers(html);
    if (parts) {
      $intro.innerHTML = parts.intro || '';
      $t1.innerHTML = parts.t1 || '';
      $t2.innerHTML = parts.t2 || '';
      $t3.innerHTML = parts.t3 || '';
      $i1.innerHTML = parts.i1 || '';
      $i2.innerHTML = parts.i2 || '';
      log('Extração por marcadores aplicada.');
    } else {
      log('Nenhum marcador explícito encontrado (Intro (H3), Text block 1...). Use "Analisar" para divisão automática.');
    }
  };

  $boldRescan.onclick = () => {
    currentBoldList = findBoldSentences($ed);
    renderBoldList(currentBoldList);
    log('Bolds re-escaneados.');
  };

  $boldApply.onclick = () => {
    applyBoldConversions();
  };

  $close.onclick = () => {
    wrap.remove();
    document.getElementById(ID + '-style')?.remove();
  };

  $fill.onclick = async () => {
    try {
      const mapping = MODELS[$model.value] || {};
      const meta = JSON.parse($log.dataset.meta || '{}');
      if (!mapping?.items?.length) { log('Selecione um modelo válido no dropdown.'); return; }
      $log.textContent = 'Abrindo Paragraphs e preenchendo…';
      const result = await fillDrupal(mapping, meta);
      $log.textContent = 'Preenchimento concluído:\n' + result;
    } catch (e) { console.error(e); log('Erro ao preencher:', e.message); }
  };
})();
